# سند معماری ماژول کشوری

این سند ساختار پیشنهادی برای پیاده‌سازی ماژول‌های کشوری در سیستم QRPay را تشریح می‌کند و همچنین چک‌لیست الزامات دیتابیس و ادمین را ارائه می‌دهد.

## ۱. ساختار پوشه و نام‌اسپیس

```
modules/
  Country/
    Base/
      Contracts/
        CountryServiceInterface.php
        FeeRuleInterface.php
      DTO/
        CountryContext.php
        PaymentMetadata.php
      Providers/
        ProviderResolver.php
      Support/
        CurrencyFormatter.php
      BaseService.php
    IR/
      Config/
        currency.php
        fees.php
        providers.php
      Database/
        migrations/
          2024_XX_XX_000001_create_ir_metadata_table.php
        seeders/
          IRProviderSeeder.php
      Providers/
        ShaparakGateway.php
        LocalBankTransfer.php
      Services/
        IRFeeRuleService.php
        IRPaymentService.php
      Resources/
        lang/fa/messages.php
        views/
          settlement.blade.php
      CountryService.php
    CN/
      Config/
        currency.php
        fees.php
        providers.php
      Database/
        migrations/
          2024_XX_XX_000001_create_cn_metadata_table.php
      Providers/
        UnionPayGateway.php
      Services/
        CNFeeRuleService.php
        CNPaymentService.php
      Resources/
        lang/zh/messages.php
        views/
          settlement.blade.php
      CountryService.php
```

### اصول ساختاری

1. **Base Layer** شامل قراردادها، DTOها و ابزارهای مشترک است که تمام کشورها از آن استفاده می‌کنند. این لایه تنها نقطه وابستگی به هسته سیستم است و باید بدون وابستگی به پیاده‌سازی‌های محلی باقی بماند.
2. هر کشور یک پوشه اختصاصی دارد که شامل پیکربندی، سرویس‌ها، ارائه‌دهندگان و منابع محلی می‌شود. این ساختار به تیم‌ها اجازه می‌دهد تغییرات را در محدوده خود مدیریت کنند.
3. سرویس اصلی هر کشور `CountryService.php` است که پیاده‌سازی `CountryServiceInterface` را ارائه می‌دهد و در Service Container به صورت دینامیک براساس کد کشور بایند می‌شود.
4. نام‌اسپیس‌ها مطابق مسیر فایل‌ها هستند؛ برای مثال کلاس `IR\Services\IRPaymentService` در `modules\Country\IR\Services` قرار دارد و باید در تمام تست‌ها به همین نام‌اسپیس ارجاع شود. از PSR-4 Autoloading در `composer.json` برای پوشه `modules/Country` استفاده کنید.
5. افزودن کشور جدید با کپی کردن اسکلت پوشه و جایگزینی پیاده‌سازی‌های خاص کشور انجام می‌شود، اما باید ابتدا از لایه Base مشتق شود تا قراردادها و تست‌های مشترک شکسته نشوند.
6. هر ماژول کشوری باید دارای تست‌های واحد (Unit Tests) و یک پوشه `tests/Country/<CC>` باشد تا رفتارهای سفارشی از طریق CI بررسی شوند.

### اجزای لایه Base

- **Contracts**: شامل اینترفیس‌های `CountryServiceInterface`, `FeeRuleInterface`, `ProviderContractInterface`. هر قرارداد باید با توضیحات DocBlock شامل ورودی/خروجی و استثناهای ممکن همراه باشد.
- **DTO**: داده‌های استاندارد مانند `CountryContext` (شامل `countryCode`, `currency`, `timezone`) و `PaymentMetadata` برای انتقال داده میان سرویس‌ها. DTOها باید ایمیوتبل باشند و از متدهای استاتیک `fromArray` استفاده کنند.
- **Providers**: `ProviderResolver` وظیفه نگاشت کد ارائه‌دهنده به کلاس درایور را دارد و باید از Container برای تزریق وابستگی استفاده کند.
- **Support**: شامل ابزارهایی نظیر `CurrencyFormatter`, `ConfigLoader`, `ValidationRules`. این ابزارها باید در صورت امکان بدون حالت و قابل استفاده مجدد باشند.

### گردش کار بارگذاری سرویس‌ها

1. یک درخواست در سطح اپلیکیشن با `country_code` مشخص وارد می‌شود.
2. `CountryModuleManager` (کلاسی در لایه Base) با توجه به `country_code`، کلاس `CountryService` متناظر را از Service Container درخواست می‌کند.
3. `CountryService` با تزریق وابستگی به `ConfigLoader`, `FeeRuleResolver` و Providerهای محلی ساخته می‌شود.
4. تمامی سرویس‌ها باید رویدادهای کلیدی مانند `PaymentAuthorized`, `SettlementRequested` را به Event Bus گزارش کنند تا سامانه‌های مانیتورینگ مشترک بتوانند واکنش نشان دهند.

### خطوط راهنمای توسعه سرویس محلی

- پیاده‌سازی سرویس‌های پرداخت باید از الگوی Template Method استفاده کند: متدهای عمومی در Base و گسترش متدهای Hook در کشور.
- برای مواردی مانند محاسبه مالیات، کلاس‌های محلی باید از `TaxStrategyInterface` استفاده کنند و در صورت نیاز پیاده‌سازی جدیدی ارائه دهند.
- تمامی پاسخ‌های API باید قبل از ارسال با کلاس‌های ولیدیشن مشترک اعتبارسنجی شوند تا ناسازگاری داده‌ای ایجاد نشود.
- برای هر کشور، حداقل یک مثال از سناریوی Happy Path و Error Path در تست‌های واحد نوشته شود.

## ۲. نیازهای متادیتای محلی

برای پشتیبانی از نیازهای خاص هر کشور بدون تغییر جداول اصلی، موارد زیر در نظر گرفته می‌شود:

| حوزه | نیاز | توضیح |
|------|------|-------|
| متادیتای پرداخت | جدول `country_payment_metadata` با فیلدهای `country_code`, `key`, `value`, `context` | نگهداری داده‌های خاص (مثلاً کد مالیات، شناسه پذیرنده) به صورت key-value. |
| پیکربندی کارمزدی | جدول `country_fee_rules` با فیلدهای `country_code`, `rule_name`, `config` (JSON) | ذخیره قوانین کارمزد قابل‌توسعه و نسخه‌پذیر. |
| نگاشت ارائه‌دهنده | جدول `country_provider_map` با فیلدهای `country_code`, `provider_code`, `driver`, `status`, `settings` (JSON) | تعریف ارائه‌دهندگان فعال و تنظیماتشان. |
| ترجمه‌ها | استفاده از فایل‌های محلی در مسیر `Resources/lang` | نیاز به migration ندارد، در فایل‌ها مدیریت می‌شود. |

### سیاست مهاجرت‌ها

- هر ماژول کشوری مهاجرت‌های مختص خود را در `modules/Country/<CC>/Database/migrations` نگه می‌دارد.
- مهاجرت‌ها باید از `Schema::createIfNotExists` استفاده کنند تا از اجرای چندباره جلوگیری شود.
- نام جداول باید با پیشوند `country_` شروع شود تا از تداخل با جداول جهانی جلوگیری شود.
- Seederهای اختصاصی (در صورت نیاز) برای داده‌های اولیه مانند ارائه‌دهندگان پیش‌فرض استفاده می‌شوند.
- هر مهاجرت کشوری باید شامل متادیتای نسخه در جدول `schema_versions` (یا جدول مشابه) ثبت شود تا وابستگی‌های بین کشورها قابل پیگیری باشد.
- از `Blueprint::uuid` برای کلیدهای خارجی به جای اعداد افزایش‌یابنده استفاده شود تا هم‌راستا با سیاست جهانی باشد.
- در مهاجرت‌هایی که ستون JSON اضافه می‌شود، شاخص‌های مناسب (GIN یا JSON Index) برای عملکرد بهتر تعریف شود.
- مهاجرت‌های کشوری نباید جدول‌های جهانی را تغییر دهند؛ در صورت نیاز به فیلد مشترک جدید، RFC جداگانه تهیه شود.

## ۳. تنظیمات قابل مدیریت در ادمین

| تنظیم | محل نگهداری | نحوه مدیریت |
|-------|--------------|--------------|
| ارز پیش‌فرض کشور | فایل `Config/currency.php` و جدول `country_payment_metadata` (برای override) | مقدار پایه در فایل پیکربندی؛ ادمین می‌تواند override را در دیتابیس ثبت کند. سیستم ابتدا DB سپس فایل را می‌خواند. |
| قوانین کارمزد | فایل `Config/fees.php` (defaults) + جدول `country_fee_rules` | پیکربندی اولیه در فایل؛ تغییرات پویا توسط ادمین در DB ذخیره می‌شود. سرویس `FeeRuleResolver` ابتدا داده DB را خوانده و در صورت نبود، فایل را استفاده می‌کند. |
| نگاشت ارائه‌دهنده | فایل `Config/providers.php` (defaults) + جدول `country_provider_map` | تعریف پایه در فایل. ادمین می‌تواند وضعیت فعال/غیرفعال و تنظیمات را از طریق ادمین پنل در DB تغییر دهد. Resolverها با اولویت DB عمل می‌کنند. |
| محدودیت‌های تراکنش | جدول `country_payment_metadata` | مقداردهی توسط ادمین برای سقف‌ها و محدودیت‌های خاص. |
| پارامترهای KYC/KYB | جدول `country_payment_metadata` با `context = 'kyc'` | فرم پویا در ادمین برای تنظیم الزامات مستندات. |

### ترکیب Config و Database

1. **Loader مشترک** در `modules/Country/Base/Support/ConfigLoader.php` پیاده‌سازی می‌شود که ابتدا داده‌های DB را با توجه به `country_code` می‌خواند و سپس روی داده‌های فایل merge می‌کند.
2. سرویس‌های کشوری (مثلاً `IRPaymentService`) از این Loader برای دریافت تنظیمات نهایی استفاده می‌کنند.
3. در صورت عدم موجودیت رکورد در DB، مقدار فایل استفاده می‌شود تا رفتار پیش‌فرض حفظ گردد.
4. تغییرات ادمین باعث ذخیره رکورد در DB می‌شود و Loader در لایه کش (Redis) تنظیمات را cache می‌کند.
5. ConfigLoader باید از الگوی Cache Aside استفاده کند: ابتدا کش، سپس DB، و در نهایت fallback به فایل. TTL پیشنهادی ۱۵ دقیقه با قابلیت Flush دستی.
6. برای تنظیمات حساس (مانند کلیدهای API)، مقدار رمزنگاری‌شده در DB ذخیره شده و در Loader با استفاده از `Crypt::decrypt` بازیابی می‌شود.
7. در محیط‌های چند مستاجری (Multi-tenant)، Loader باید پارامتر `tenant_id` را نیز دریافت کرده و داده‌ها را Segment کند.
8. نسخه‌بندی تنظیمات از طریق ستون `version` در جدول‌های پیکربندی انجام می‌شود و سرویس‌ها باید قدیمی بودن نسخه را شناسایی و Log کنند.

## ۴. چک‌لیست الزامات دیتابیس و ادمین

### دیتابیس

- [ ] ایجاد جداول `country_payment_metadata`, `country_fee_rules`, `country_provider_map` به صورت عمومی (global migrations).
- [ ] تعریف Migrationهای سفارشی هر کشور در مسیر خود و استفاده از prefix `country_`.
- [ ] اطمینان از افزودن شاخص‌های ترکیبی روی `(country_code, key)` و `(country_code, provider_code)`.
- [ ] پیاده‌سازی Seederهای اختیاری برای داده‌های اولیه هر کشور.
- [ ] مستندسازی نسخه و ترتیب اجرای مهاجرت‌های کشوری.

### ادمین

- [ ] ایجاد فرم مدیریت ارز و override در پنل ادمین (وابسته به `country_payment_metadata`).
- [ ] پیاده‌سازی رابط مدیریت قوانین کارمزد با امکان فعال/غیرفعال کردن.
- [ ] افزودن مدیریت نگاشت ارائه‌دهنده شامل اضافه/حذف/ویرایش و وضعیت.
- [ ] افزودن رابط مدیریت محدودیت‌های تراکنش و پارامترهای KYC.
- [ ] اتصال فرم‌های ادمین به Loader تنظیمات برای invalidate کردن cache پس از ذخیره.
- [ ] ثبت رویدادهای Audit (چه کسی، چه زمانی، چه تغییری) در جدول `admin_audit_logs` برای تمام تغییرات کشوری.
- [ ] افزودن قابلیت تست تنظیمات (Test Connection) برای هر ارائه‌دهنده به منظور اطمینان از صحت تنظیمات جدید.
- [ ] فراهم کردن امکان Export/Import تنظیمات کشوری در قالب JSON امضاشده برای انتقال بین محیط‌ها.

## ۵. یکپارچه‌سازی با سامانه‌های مرکزی

- **سرویس‌های پیام‌رسانی**: هر ماژول کشوری باید Eventهای خود را با الگوی نام‌گذاری `country.<CC>.<event>` در Kafka یا RabbitMQ منتشر کند تا سامانه‌های جهانی بتوانند Subscription انجام دهند.
- **گزارش‌دهی مالی**: خروجی Settlement باید با فرمت استاندارد `SettlementReportDTO` در پوشه `Base/DTO` هماهنگ باشد تا ماژول‌های حسابداری بدون تغییر کار کنند.
- **API‌های خارجی**: اگر کشور نیازمند API جدیدی است، Gateway مرکزی باید با Feature Flag مسیر را فعال کند و مستند Swagger در `/docs/countries/<CC>.yaml` به‌روزرسانی شود.
- **همگام‌سازی کاربران**: از Jobهای زمان‌بندی‌شده (Scheduler) در پوشه `Modules/Country/<CC>/Jobs` برای سنکرون‌کردن داده‌های کاربران با سیستم‌های Identity استفاده کنید.

## ۶. الزامات امنیت و انطباق

- **حفاظت داده**: تمامی داده‌های حساس (مانند شماره ملی، شناسه مالیاتی) باید در زمان ذخیره‌سازی با `Encryptable` Trait رمزنگاری شوند و دسترسی به آن‌ها با Policy جداگانه کنترل شود.
- **انطباق قانونی**: برای هر کشور سند `compliance.md` در مسیر `modules/Country/<CC>/` نگهداری شود تا الزامات مانند PCI-DSS، قوانین ضدپولشویی و نگهداری داده مستند گردد.
- **ممیزی دسترسی**: دسترسی سرویس‌ها به Providerهای خارجی باید از طریق Secret Manager مرکزی انجام شود و کلیدها در فایل پیکربندی قرار نگیرند.
- **مدیریت خطا**: تمامی استثناهای حساس باید قبل از لاگ شدن به پیام عمومی تبدیل شوند تا اطلاعات حساس در لاگ‌ها افشا نشود.

## ۷. عملیات و مانیتورینگ

- [ ] تعریف داشبورد اختصاصی در ابزار مانیتورینگ (مانند Grafana) برای هر کشور شامل متریک‌های تراکنش، خطا و تاخیر.
- [ ] ثبت لاگ‌های ساختاریافته با فیلدهای `country_code`, `provider_code`, `request_id` برای ردیابی سریع.
- [ ] راه‌اندازی آلارم برای خطاهای پرتکرار (۵xx) با تفکیک کشور.
- [ ] مستندسازی Runbook حل خطاهای رایج هر کشور و لینک دادن آن در داشبورد.

## ۸. تست و تضمین کیفیت

- [ ] تعریف تست‌های Contract برای اطمینان از انطباق سرویس کشوری با قراردادهای Base.
- [ ] افزودن سناریوهای End-to-End در محیط Stage با داده‌های نمونه واقعی هر کشور.
- [ ] استفاده از Feature Flag برای انتشار تدریجی کشور جدید و قابلیت Rollback سریع.
- [ ] نگارش مستند تست پذیرش (UAT) با همکاری تیم محلی و ثبت نتایج در Confluence.

---

این سند مبنای پیاده‌سازی ماژول‌های کشوری بوده و باید در کنار مستندات فنی دیگر به‌روزرسانی شود.
